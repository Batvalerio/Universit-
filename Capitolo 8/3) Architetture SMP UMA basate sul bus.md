- I multiprocessori più semplici sono basati su ==un **singolo bus**==. Due o più CPU e uno o più moduli di memoria utilizzano lo stesso bus per la comunicazione.
- Quando una CPU vuole leggere una parola di memoria, controlla prima se il bus è occupato. Se è libero, la CPU pone l’indirizzo della parola richiesta sul bus, attiva alcuni segnali di controllo e aspetta finché la memoria pone la parola desiderata sul bus.
- Se il bus è occupato quando una CPU vuole leggere o scrivere in memoria, la CPU aspetta fino a che il bus è libero. Questo è il problema principale di questa architettura: con un gran numero di CPU (32 o 64), la contesa per il bus diventa insostenibile. Il sistema sarà quindi limitato dalla larghezza di banda del bus, e la maggior parte delle CPU rimarrà inattiva per gran parte del tempo.
- La soluzione a questo problema consiste nell’aggiungere ==una **cache**== a ciascuna CPU. Questa cache può essere sul chip della CPU, vicino al suo chip, sulla scheda del processore, o in una combinazione di tutti e tre. Poiché molte letture possono ora essere soddisfatte dalla cache locale, ci sarà meno traffico sul bus, e il sistema potrà supportare un maggior numero di CPU.
- In generale, il meccanismo di cache non è basato su una singola parola, ma su blocchi di 32 o 64 byte: quando si fa riferimento ad una parola, tutto il suo blocco è prelevato nella cache della CPU che lo ha richiesto.
- Ogni blocco della cache può essere marcato come ==**sola lettura**== (e quindi può essere presente in diverse cache contemporaneamente) o ==**lettura-scrittura**== (e quindi non può essere presente in altre cache).
- Se una CPU tenta di scrivere una parola contenuta in una o più cache remote, l’hardware del bus intercetta la scrittura ed emette un segnale sul bus per informare tutte le altre cache della scrittura.
- Se le altre cache hanno una copia “pulita” (cioè, una copia esatta di ciò che si trova in memoria), possono scaricarla, permettendo alla CPU scrittrice di prelevare il blocco della cache dalla memoria prima di modificarlo.
- Se una cache ha una copia “sporca” (cioè modificata), deve riscriverla in memoria prima che la scrittura inizi, oppure trasferirla direttamente alla CPU scrittrice sul bus. Esistono molti protocolli di trasferimento della cache.
- Un’altra possibilità è l’architettura in cui ciascuna CPU ha non solo una cache, ma anche una ==**memoria locale e privata**==, a cui accede tramite un bus dedicato (privato).
- Per utilizzare al meglio questa configurazione, il compilatore dovrebbe posizionare tutto il testo del programma, le stringhe, le costanti e gli altri dati in sola lettura, gli stack e le variabili locali nelle memorie private; la memoria condivisa allora sarebbe usata solo per le variabili condivise scrivibili.
- Nella maggior parte dei casi, un tale accurato posizionamento ridurrà di molto il traffico sul bus, richiedendo però un’attiva collaborazione da parte del compilatore