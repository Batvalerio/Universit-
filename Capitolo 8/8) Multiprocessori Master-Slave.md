- ==**Modello Master-Slave**:== In questo modello, il sistema operativo e le sue tabelle sono presenti solo sulla CPU 1, e non sulle altre. Tutte le chiamate di sistema sono reindirizzate alla CPU 1 per essere elaborate. Questo modello è chiamato master-slave, con la CPU 1 che funge da ‘master’, e tutte le altre CPU che agiscono come ‘slave’.
- ==**Risoluzione dei problemi**:== Il modello master-slave risolve la maggior parte dei problemi presenti nel modello precedente. C’è una sola struttura dati che tiene traccia dei processi pronti, e quando una CPU è inattiva, richiede al sistema operativo un processo, che le viene assegnato. In questo modo, non accade mai che una CPU sia inattiva, mentre un’altra è sovraccarica.
- ==**Allocazione dinamica delle pagine**:== Le pagine sono allocate dinamicamente tra tutti i processi, ed esiste una sola cache, quindi non si verificano mai inconsistenze.
- ==**Collo di bottiglia del Master**:== Con molte CPU, il master diventa un collo di bottiglia, perché deve gestire tutte le chiamate di sistema, per tutte le CPU. Se ad esempio il 10% del tempo passa nella gestione delle chiamate di sistema, dieci CPU saturano il master, e con venti CPU il sistema è sovraccarico.
- ==**Limitazioni del modello**:== Questo modello è semplice e utilizzabile per piccoli sistemi multiprocessori, ma non per quelli più grandi.
![[Pasted image 20240517103652.png]]